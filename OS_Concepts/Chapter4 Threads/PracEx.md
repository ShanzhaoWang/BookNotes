4.1 (page21) 
* Provide three programming examples in which multithreading provides better performance than a single-threaded solution.
  * Web browsers: parallel downloads
  * Web servers: handle multiple concurrent clients, services each request in a separate thread
  * Word processors: spell check in the background 
  * GUI: different threads are executed for different tasks, such as debugger where a thread is used to monitor user input, another thread represents the running application, and a third thread monitors performance.
  
4.2 (page22)
* What are two differences between `user-level threads` and `kernel-level threads`? Under what circumstances is one type better than the other?
  * User-level threads are unknown by the kernel, whereas the kernel is aware of kernel threads
  * On systems using either `M:1` or `M:N` mapping, user threads are scheduled by the `thread library` and the `kernel` schedules kernel threads
  * Kernel threads need not be associated with a process whereas every user thread belongs to a process. `Kernel threads` are generally `more expensive to maintain` than user threads as they must be represented with a kernel data structure.
  * User > Kernel level threads:
    * If the kernel is `time shared`, then user-level threads are better than kernel-level threads.
      * because in time shared systems context switching takes place **frequently**. Context switching between kernel level threads has high overhead, almost the same as a process whereas context switching between user-level threads has almost no overhead as compared to kernel level threads
  * Kernel >> User level threads:
    * If the kernel is single-threaded,...,block
4.3 
* Describe the actions taken by a kernel to context-switch between `kernel-level threads`
  * Kernel:
    * Kernel is the head of any operating system
    * Several threads with different tasks are `executed` by the kernel
    * The interrupts generated by multi-threading are handled by kernel
    
  * Context switching between kernel threads typically requires `saving the value of the CPU registers` from the thread being switched out and restoring the CPU registers of the new thread being scheduled.
  
  
  
4.4 
* What resources are used when a thread is created? How do they differ from those used when a process is created?
  * Because a thread is smaller than a process, thread creation typically uses fewer resources than process creation. 
  * Creating a process requires allocating a process control block (PCB), which includes a `memory map`, `list of open files`, and `environment variables`. Allocating and managing the memory map is typically the most time-consuming activity.
  * Creating either a user or kernel thread involves allocating a small data strcture to hold a `thread ID`, a `program counter`, a `register set`, `stack`, and `priority`. 
  * Resources are used when a thread is created: 1. Code Section 2. Data Section and 3. Other OS resources such as open files and signals with other threads belonging to the same process whereas each and every process has separate code section, data section and operating system resources.


4.5 X

4.6
* Provide two programming examples in which multithreading does not provide better performance than a single-threaded solution
  * In the `linear programming`, programs like computing the factorial of a number, sorting numbers, and minimizing the linear equations provide better performance using the single thread.
  * The multithreading does not provide better performance in the `"shell programs"`. The shell programs use the single thread to execute the program. 
  
4.7 X

4.8
* Which of the following components of program state are shared across threads in a multithreaded process?
  * `Heap memory` and `Global variables` are shared in multithread process
  * Each thread in multithread process has its `own stack` and `register values`.
  
4.9
* Can a multithreaded solution using multiple user-level threads achieve better performance on a `multiprocessor system` than on a `single-processor system`? Explain.
4.10
* In Chapter 3, we discussed Googleâ€™s Chrome browser and its practice of opening each new website in a separate `process`. Would the `same benefits` have been achieved if instead Chrome had been designed to open each new website in a separate `thread`? Explain.
  * Browser maintains to open each new website as an independent process rather than opening them as threads to ensure that no website breakdown affects others' service.
  * Openning new website as a thread `CANNOT` maintain the efficiency of the browser, because threads are allocated with `shared memory spaces`. Hence they may affect each other if one of them crashes unexpectedly.

4.16 (Page36 4.7.2)
* As described in Section 4.7.2, Linux does not distinguish between processes and threads. Instead, Linux treats both in the same way, allowing a task to be more akin to a process or a thread depending on the set of flags passed to the clone() system call. However, other operating systems, such as Windows, treat processes and threads differently. Typically, such systems use a notation in which the data structure for a process contains pointers to the separate threads belonging to the process. Contrast these two approaches for modeling processes and threads within the kernel.


4.17
4.18 (Homework 2.7)
Consider a multicore system and a multithreaded program written using the many-to-many threading model. Let the number of user-level threads in the program be greater than the number of processing cores in the system. Discuss the performance implications of the following scenarios.
a. The number of kernel threads allocated to the program is less than the number of processing cores.
b. The number of kernel threads allocated to the program is equal to the number of processing cores.
c. The number of kernel threads allocated to the program is greater than the number of processing cores but less than the number of user-level threads.


4.19 X
