* 内存管理从根本上说是操作系统对存储设备进行的抽象和装扮
* 核心思想：虚拟内存，通过这种机制，操作系统将内存的容量扩增或无限增大，将内存的访问速度大幅度提高，而其使用的“原料”却很简单：一点点缓存，一些主存和便宜的磁盘；机制：动态地址翻译！

## 1.内存管理的环境
* 理想状态下，程序员对内存的要求是：**大容量**，**高速度**和**持久性**
* 物理现实：由缓存、主存、磁盘组成的一个**内存架构**
  * 缓存：低容量、高速度、高价格
  * 主存：中容量、中速度、中价格
  * 磁盘：大容量、低速度、低价格
* 内存管理就是对内存架构进行管理，使程序在内存架构的任何一个层次上的存放对于用户来说都是一样的。用户无需担心自己的程序是存在缓存、内存、磁盘还是磁带，反正运行、计算、输出的结果都一样
* 让内存管理实现这种**媒介透明**的手段就是**虚拟内存**：操作系统提供给用户另一个“幻象”，幻象构建在内存架构的顶端，给用户提供一个比物理主存空间大许多的地址空间

## 2.内存管理的目标
* 提供一个虚幻的抽象满足人类的渴望和需要
* 地址保护：一个程序不能访问另一个程序地址空间 
> 由于**多道程序**同时存放在内存中，操作系统要保证它们之间互不干扰————一个进程不能随便访问另一个进程的地址空间
* 地址独立：程序发出的地址应与物理主存地址无关
> 程序指令在执行前被加载到内存，然后从内存中一条条指令读出，然后执行。每条指令在执行时需要读取操作数和写入运算结果，而读取操作数，就要需要`给出操作数所在的内存地址`，这个地址不能是物理主存地址，因为该程序在何种硬件配置的机器上运行不能事先确定，操作系统自然不可能对症下药地发出对应于某台机器的物理主存地址。  
> 因此，`指令里面的地址`是程序空间（虚拟空间）和虚拟地址（程序地址），即`程序发出的地址`与具体机器的物理主存地址是独立的。

## 3.虚拟内存的概念
* 物理主存的容量非常有限，虚拟内存的中心思想是将物理主存扩大到便宜、大容量的磁盘上、即`将磁盘空间看作是主存空间的一部分`
* 虚拟内存要提供的就是一个空间像磁盘那样大、速度像缓存那样高的主存储系统，而对程序地址所在位置（缓存、主存、磁盘）的判断则是内存管理系统的一个中心功能

## 4.操作系统在内存的位置
* RAM：随机访问存储，内存，操作系统为用户提供服务，占用的区域在用户程序占用的区域之下
  * 置于地址空间的下面的好处：在复位、中断、陷入等操作时，控制移交给操作系统更方便，因为操作系统的起始地址为0，无需另行记录操作系统所处的位置，`程序计数器清0`就可以了。清零操作对于硬件来说非常简单，无需从总线读取任何数据
* 根据操作系统是否占用ROM或是否采用`内存映射`的输入输出来分，存在两种模式：
  * 操作系统占用RAM的底层，用户程序占用RAM的上层
  * 操作系统占用RAM的底层和位于用户程序地址空间上面的ROM。用户程序位于中间。
    * 没有使用内存映射的输入输出，ROM里面全部是操作系统
    * 使用了内存映射的输入输出，ROM的一部分是操作系统，另一部分属于I/O设备
    * 使用了内存映射的输入输出，ROM全部属于I/O设备

## 5.单道编程的内存管理
* 

## 6.多道编程的内存管理
* 操作系统更加复杂，无法将程序总是加到**固定的**内存地址上，也就是无法使用静态地址翻译。这样我们就必须在程序**加载完毕后**才能计算物理地址，也就是在程序运行时进行地址翻译。这种翻译称为动态地址翻译：由MMU地址翻译器把用户进程发出的虚拟地址翻译成物理地址

### 6.1 固定分区的多道编程内存管理
* 固定分区的管理就是将内存分为固定的几个区域，每个区域的大小固定，最下面的分区为操作系统占用，其他分区由用户程序使用。
### 6.2 地址翻译的方法
```
物理地址=虚拟地址+程序所在区域的起始地址（程序基址）
```
基址寄存器存放固定内存分区中各个区域的起始内存地址，极限寄存器存放所加载程序的长度（不是内存各个分区的上限）
### 6.3 动态地址翻译的优点

### 6.4 非固定分区的内存管理
## 7.闲置空间管理
* 
