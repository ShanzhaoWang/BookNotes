5.1 进程的分身术——线程
* 线程是我们为了让一个进程能同时干多件事情而发明的“分身术”
* 线程是进程的分身，每个线程自然在本质上一样，拥有同样的程序文本
  * 不同：线程执行时的上下文不一致，线程是进程里面的一个执行上下文，或者执行序列。
* 同一个地址空间里面的所有线程就构成里进程
* 将进程分解为线程还可以有效利用多处理器和多核计算机 --> 提高进程的执行速度
> Microsoft Word，多线程：一个负责显示，一个接受输入，一个定时进行存盘


5.2 线程管理
* 线程共享一个进程空间，因此许多资源是共享的
  * 共享的资源显然不需要存放在线程控制块里面，而是存放在进程控制块即可
  * 不被共享的资源和信息存放在线程控制块里
  * 发明线程的动机：应当让共享的资源越多越好
  * 标准：如果某资源**不独享会导致线程运行错误**，则该资源就由每个线程独享；而其他资源都由进程里面的所有线程共享
    * 共享：地址空间、全局变量、文件、子进程
    * 独享：程序计数器，因为每个线程的执行序列不一样、寄存器和栈，因为这是**线程的上下文（运行环境）**
 

5.3 线程的实现方式
* 既然线程是进程的构成部分，或者是进程的分身，那么由谁来管理线程就有两种选择：
  * 进程自己管理线程 ==> 用户态线程实现
  * 操作系统管理线程 ==> 内核态线程实现
* 内核态线程实现：
  * 
  
* 用户态线程实现： 
  * 线程是进程的分身，
  * 
* 注意：进程的实现


5.4 现代操作系统的线程实现模型
* 用户态和内核态都存在缺陷，现代操作系统使用的是将二者结合起来
  * 用户态的执行系统负责进程内部线程[在非阻塞时的]**切换**；
  * 内核态的操作系统负责阻塞
  
  
5.5 多线程的关系
* 


5.6 讨论：从用户态进入内核态
*


5.7 讨论：线程的困惑 - 确定性与非确定性
* 线程很有用，因为实现了进程内部的并发
* 在进程级别上实现了多道编程，使得一个进程可以同时干多件事情，提高了程序运行的效率，提高了硬件资源的使用率
* 程序层面的并发性能



